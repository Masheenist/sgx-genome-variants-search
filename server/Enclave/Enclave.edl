#include "../include/config.h"

enclave
{
	include "sgx_trts.h"
	include "sgx_utils.h"
	include "sgx_tkey_exchange.h"

	from "sgx_tkey_exchange.edl" import *;

	trusted
	{
		include "config.h"

		public sgx_status_t ecall_thread_cms(int thread_num);
		public sgx_status_t ecall_thread_cms_ca(int thread_num, int part_num);
		public sgx_status_t ecall_thread_csk(int thread_num);

		public sgx_status_t get_report([out] sgx_report_t* report, [in] sgx_target_info_t* target_info);

		public size_t get_pse_manifest_size();

		public sgx_status_t get_pse_manifest([out, count=sz] char *buf, size_t sz);

		public sgx_status_t enclave_ra_init(sgx_ec256_public_t key, int b_pse, [out] sgx_ra_context_t* ctx, [out] sgx_status_t* pse_status);

		public sgx_status_t enclave_ra_init_def(int b_pse, [out] sgx_ra_context_t* ctx, [out] sgx_status_t* pse_status);

		public sgx_status_t enclave_ra_close(sgx_ra_context_t ctx);

		// Application specific enclave functions
		public void enclave_derive_key(sgx_ra_context_t ctx);

		// Public ECALL interface for getting results out of the enclave
		// NOTE: This output is NOT encrypted since this a proof of concept
		public void enclave_get_res([out, size = 524288] uint32_t* res);
		public void enclave_get_res_buf([out, size = 4000] uint32_t* res);

		// Open-Addressing Hash-Table public ECALL interface
		public void enclave_init_oa();
		public void enclave_decrypt_process_oa(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);

		// Robin-Hood-Hash-Table public ECALL interface
		public void enclave_init_rhht();
		public void enclave_decrypt_process_rhht(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);

		// Three-Pass version
		public void enclave_init_sketch_rhht();
		public void enclave_decrypt_process_sketch_rhht(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);

		// Chained-Move-to-Front Hash Table public ECALL interface
		public void enclave_init_cmtf();
		public void enclave_decrypt_process_cmtf(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len, uint32_t type);

		// Count-Min-Sketch public ECALL interface
		public void enclave_init_cms();
		public void enclave_decrypt_update_cms(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);
		public void enclave_decrypt_query_cms(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);

		// Multi-threaded CMS public ECALL interface
		public void enclave_decrypt_store_cms(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);
		public void enclave_update_cms(sgx_ra_context_t ctx, uint32_t thread_num);
		public void enclave_clear_cms(sgx_ra_context_t ctx);

		// Count-Sketch public ECALL interface
		public void enclave_init_csk();
		public void enclave_decrypt_update_csk(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);
		public void enclave_decrypt_query_csk(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);

		// Multi-threaded CSK public ECALL interface
		public void enclave_decrypt_store_csk(sgx_ra_context_t ctx, [user_check] uint8_t* ciphertext, size_t ciphertext_len);
		public void enclave_update_csk(sgx_ra_context_t ctx, uint32_t thread_num);
		public void enclave_clear_csk(sgx_ra_context_t ctx);

		// Min-Heap public ECALL interface
		public void enclave_init_mh();

		// Chi-Squared Test public ECALL interface
		public void oa_init_chi_sq(uint16_t case_count, uint16_t control_count);
		public void rhht_init_chi_sq(uint16_t case_count, uint16_t control_count);
		public void cmtf_init_chi_sq(uint16_t case_total, uint16_t control_total);
	};
    
	untrusted
	{
		include "config.h"
	};
};
